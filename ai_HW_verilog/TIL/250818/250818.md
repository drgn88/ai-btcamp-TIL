# Review : RV32I R-Type

## RV32I Architecture

- 중심은 Data를 중심으로 설계
  - **Register File**
- **Instruction Memory**(Harvard Architecture)
  - ROM에 저장
    - 최근엔 Flash Memory에 저장
  - Machine Code가 저장돼있음
  - 들어오는 Address에 따라서 명령어가 나감
    - **Program Counter**에서 알려줌
- **Program Counter**
  - Instruction Memory가 출력할 Instruction Code의 주소를 알려줌
  - 32bit CPU의 경우 **PC**의 값을 4씩 증가
    - 주소는 1B단위
    - 32bit CPU의 주소는 4B단위

### Q. alu control 신호를 Data Path에 직접 연결 안하는 이유

- 지금은 R Type만 다루니 그렇게 해도 상관없음
- 그러나 opcode의 타입이 증가하면 opcode에 따라 control 신호가 다르게 들어감
- 이를 중계할 **Control Unit**이 필요함


## `define

- code의 가독성 높이기 위해 사용
```verilog
case (aluControl)
	4'b0000: result = a + b;  //add
	4'b1000: result = a - b;  //sub
	4'b0001: result = a >> b;  //sll
	4'b0101: result = a >> b;  //srl
	4'b1101: result = $signed(a) >>> b;  //sra
	4'b0010: result = ($signed(a) < $signed(b)) ? 1 : 0;  //slt
	4'b0011: result = (a < b) ? 1 : 0;  //sltu
	4'b0100: result = a ^ b;  //xor
	4'b0110: result = a | b;  //or
	4'b0111: result = a & b;  //and
endcase
```
- 가독성이 좋지 않음

### `define을 쓸 때

```verilog
`define ADD 4'b0000
`define SUB 4'b1000
`define SLL 4'b0001
`define SRL 4'b0101
`define SRA 4'b1101
`define SLT 4'b0010
`define SLTU 4'b0011
`define XOR 4'b0100
`define OR 4'b0110
`define AND 4'b0111

case (aluControl)
	`ADD : result = a + b;  //add
	`SUB : result = a - b;  //sub
	`SLL : result = a >> b;  //sll
	`SRL : result = a >> b;  //srl
	`SRA : result = $signed(a) >>> b;  //sra
	`SLT : result = ($signed(a) < $signed(b)) ? 1 : 0;  //slt
	`SLTU: result = (a < b) ? 1 : 0;  //sltu
	`XOR : result = a ^ b;  //xor
	`OR : result = a | b;  //or
	`AND : result = a & b;  //and
endcase
```

- 훨씬 더 코드 가독성이 올라감
- 주석도 필요없어짐

# RV32I - S Type (S: STORE)

<img src="./img/스크린샷 2025-08-18 111842.png"><br>

## S Type 특징
- 외부에 **RAM**이 있다
  - RAM == **Data Memory**
- CF) ROM(Instruction Memory)
  - Write할 수 없음
  - Only **Read**

> RAM: Random Access Memory
> > 저장장치에서 사용자가 원하는 위치의 데이터를 바로 가져올 수 있다
> >> 이전엔 릴테이프를 감아서 그 위치까지 찾아가야 함

> Imm값은 R Type에서만 사용하지 않는다

- ⭐⭐⭐12비트의 Imm를 32비트로 확장할 때는 부호비트를 확장해줘야 한다
  - 부호비트 확장의 이유
    - IMM == OFFSET
    - OFFSET이 올라갈수도 **내려갈수도** 있기 때문
    - 빼기의 여부는 컴파일러(C Compiler)가 판단하여 결정

# RV32I - L Type (L: LOAD)

<img src="./img/스크린샷 2025-08-18 141347.png"><br>

- **RAM**에서 데이터를 읽어옴


# Machine Code

- Instruction Set Architecture에 따라 Machine Code가 다름
- 컴파일러한테 옵션으로 어떤 Machine Code인지 알려줘야함
  - 이에 맞게 컴파일러가 해석함