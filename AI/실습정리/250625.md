## 목차

# Video capture

## Code
```python
import cv2
import numpy as np

topLeft = (50, 50)
bold = 0

cap = cv2.VideoCapture(4)

# Callback function for the trackbar
def on_bold_trackbar(value):
    #print("Trackbar value:", value)
    global bold
    bold = value
    
    
cv2.namedWindow("Camera")
cv2.createTrackbar("bold", "Camera", bold, 10, on_bold_trackbar)

#성공적으로 video device가 열리면 while문 반복
while(cap.isOpened()):
    #한 프레임을 읽어옴
    ret, frame = cap.read()
    if ret is False:
        print("Can't receive frame (stream end?). Exiting...")
        break
    # Text
    cv2.putText(frame, "TEXT", topLeft, cv2.FONT_HERSHEY_SIMPLEX, 2, (0,255,255), 1 + bold)
    
    # Display
    cv2.imshow("Camera", frame)
    
    key = cv2.waitKey(1)
    if key & 0xFF == ord('q'):
        print("사용자가 'q'를 눌렀습니다. 종료합니다...")
        break

# 사용이 끝난 카메라 자원 해제
cap.release()
# 열려있는 모든 창 닫기
cv2.destroyAllWindows()
```

## 설명

### cv2.VideoCapture(port)
- 카메라로부터 들어오는 영상을 저장한다
- cap이라는 변수는 카메라 영상을 담는 역할을 한다

### cv2.createTrackbar(trackbarname, winname, value, count, onChange)
- trackbarname: 트랙바 이름
- winname: 트랙바를 띄울 창의 이름
- value: 트랙바의 초기값
- count: 트랙바의 최대값
- onChange
  - CallBack 함수
  - 트랙바의 값이 변경될 때마다 자동으로 호출됨
  - 정수 인자 하나를 반드시 리턴 받아야함

#### on_board_trackbar
- 트랙바가 움직일 때마다 트랙바의 값이 전달됨
- 전달된 트랙바의 값이 bold에 업데이트됨
- 그러면 해당 값으로 트랙바의 값이 설정됨

### cap.read
- ret: retrun Value
  - 프레임을 성공적으로 읽어왔는지의 여부
- frame: 실제 읽어온 프레임 데이터
  - Numpy 배열 형태의로 픽셀 데이터를 저장함

### cv2.putText(img, text, org, fontFace, fontScale, color, thickness, lineType)
- img: 텍스트를 그릴 이미지 대상
- text: 실제 출력할 문자열
- org
  - 텍스트가 시작될 좌표
- fontFace
  - 텍스트의 폰트 결정
- fontScale
  - 폰트의 크기 배율을 결정함
- color
  - 폰트 색 결정
- thickness
  - 글씨 굵기
- lineType
  - 텍스트 선의 종류

## 결과
<img src="./img_250625/Screenshot from 2025-06-25 10-37-22.png"><br>

