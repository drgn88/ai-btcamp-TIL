## 목차
- [1. jpeg -\> png로 저장](#1-jpeg---png로-저장)
  - [Code](#code)
- [2. RGB, HSV 색공간 비교](#2-rgb-hsv-색공간-비교)
  - [Code](#code-1)
  - [결과](#결과)
    - [BGR](#bgr)
    - [HSV](#hsv)
- [3. Crop/ Resize](#3-crop-resize)
  - [Code](#code-2)
  - [결과](#결과-1)
    - [Original Image](#original-image)
    - [Resized Image](#resized-image)
    - [Cropped Image](#cropped-image)
    - [Rotate Image](#rotate-image)
- [4. 필터](#4-필터)
  - [Code](#code-3)
  - [결과](#결과-2)
    - [Laplacian](#laplacian)
    - [Sobel](#sobel)
    - [Canny Edge](#canny-edge)
- [5. 카메라로 영상 입력받아 동영상 파일로 저장하기](#5-카메라로-영상-입력받아-동영상-파일로-저장하기)
  - [Code](#code-4)

# 1. jpeg -> png로 저장

## Code
```python
import numpy as np
import cv2

# 이미지 파일을 Read
img = cv2.imread("../image_dir/my_input_bo.jpeg")

# Image란 이름의 Display 창 생성
cv2.namedWindow("image", cv2.WINDOW_NORMAL)

# Numpy ndarray H/W/C order
print(img.shape)

# Read한 이미지 파일을 Display
cv2.imshow("img", img)

# 키 입력 대기
cv2.waitKey(0)

# output.png로 읽은 이미지 파일을 저장
cv2.imwrite("output.png", img)

# Destroy all windows
cv2.destroyAllWindows()
```

1. imread
  - 이미지를 읽어옴
<img src="../TIL/img_250624/Screenshot from 2025-06-24 12-23-18.png"><br>

2. cv2.namedWindow("image", cv2.WINDOW_NORMAL)
  - cv2.namedWindow()
    - 이미지나 비디오를 표시하기 위한 창
  - cv2.WINDOW_NORMAL
    - 창의 속성을 설정
    - WINDOW_NORMAL은 일반적인 창을 의미
    - 사용자가 창의 크기를 조절 가능

3. cv2.imwrite()
   - image 파일을 저장

4. img.shape
   - NumPy 배열의 각 차원을 튜플 형태로 반환
   - image의 경우
   - (높이, 너비, 채널 수)
   - 채널 수는 이미지 색상 채널을 의미함
     - RGB는 3채널


# 2. RGB, HSV 색공간 비교

## Code
```python
import cv2
import numpy as np

# 이미지 파일을 Read하고 color space 정보 출력
color = cv2.imread("../image_dir/strawberry.jpg", cv2.IMREAD_COLOR)

# color = cv2.imread("strawberry_dark.jpg", cv2.IMREAD_COLOR)
print(color.shape)

height,width,channels = color.shape
cv2.imshow("Original Image",color)

# Color Channel을 B, G, R로 분할하여 출력
b,g,r = cv2.split(color)
rgb_split = np.concatenate((b,g,r), axis = 1)
cv2.imshow("BGR Channels", rgb_split)

# 색공간을 BGR에서 HSV로 변환
hsv = cv2.cvtColor(color, cv2.COLOR_BGR2HSV)

# 색공간을 BGR에서 흑백으로 변환
gray = cv2.cvtColor(color, cv2.COLOR_BGR2GRAY)

# Color Channel을 B, G, R로 분할하여 출력
g = cv2.split(gray)
rgb_split_g = np.concatenate(g, axis = 1)
cv2.imshow("Gray Channels", rgb_split_g)

# Channel을 H, S, V로 분할하여 출력
h,s,v=cv2.split(hsv)
hsv_split = np.concatenate((h,s,v),axis= 1)
cv2.imshow("Split HSV", hsv_split)

cv2.waitKey()
```

## 결과
> 참고) opencv는 BGR 순으로 저장함


### BGR
<img src="./img_2506524/Screenshot from 2025-06-24 17-54-13.png"> <br>
- 딸기는 Red 픽셀값이 높고 나머지 B, G는 기 비율이 낮음
- R 채널은 픽셀값이 높아 밝음
- B의 경우 픽셀값이 0에 수렴해 어두운 것을 확인 가능

### HSV
<img src="./img_2506524/Screenshot from 2025-06-24 17-57-39.png"><br>

# 3. Crop/ Resize

## Code
```python
import cv2
import numpy as np

# 이미지 파일을 Read
img = cv2.imread("../image_dir/puffin.jpg")

# Crop 300X400 from original image from (100,50) = (x,y)
cropped = img[50:450, 100:400]

# Resize cropped image from 300X400 to 400X200
resized = cv2.resize(cropped, (400,200))

# Image 회전
rotate_90 = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)

# Display all
cv2.imshow("Original", img)
cv2.imshow("Cropped image", cropped)
cv2.imshow("Resized image", resized)
cv2.imshow("Rotate image", rotate_90)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

## 결과

### Original Image
<img src="./img_2506524/Screenshot from 2025-06-24 18-06-17.png"><br>

### Resized Image
<img src="./img_2506524/Screenshot from 2025-06-24 18-06-23.png"><br>

### Cropped Image
<img src="./img_2506524/Screenshot from 2025-06-24 18-06-29.png"> <br>

### Rotate Image
<img src="./img_2506524/Screenshot from 2025-06-24 18-06-35.png"><br>

# 4. 필터

## Code
```python
import cv2

src = cv2.imread("../image_dir/road.jpeg", cv2.IMREAD_COLOR)
gray = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)

sobel  = cv2.Sobel(gray, cv2.CV_8U, 1, 0, 3)
laplacian = cv2.Laplacian(gray, cv2.CV_8U)
canny = cv2.Canny(gray,100,200)

cv2.imshow("sobel", sobel)
cv2.imshow("laplacian", laplacian)
cv2.imshow("canny", canny)

cv2.waitKey()
cv2.destroyAllWindows()
```

## 결과

### Laplacian
<img src="./img_2506524/Screenshot from 2025-06-24 18-10-55.png"><br>

### Sobel
<img src="./img_2506524/Screenshot from 2025-06-24 18-10-48.png">

### Canny Edge
<img src="./img_2506524/Screenshot from 2025-06-24 18-11-01.png"><br>

# 5. 카메라로 영상 입력받아 동영상 파일로 저장하기

## Code
```python
import cv2
import numpy as np
import sys # 프로그램 종료를 위해

# Read from the first camera (index 0, or try 1, 2, 3, etc. if 0 doesn't work)
# cv2.CAP_DSHOW is often problematic, so it's good you removed it for testing.
# Let's keep the current index (4) or try 0 if 4 is not working.
camera_index = 4 # 현재 코드의 인덱스 유지
# camera_index = 0 # 대부분의 경우 0번이 기본 웹캠입니다.

cap = cv2.VideoCapture(camera_index)

# Check if the camera opened successfully
if not cap.isOpened():
    print(f"오류: 카메라 {camera_index}번을 열 수 없습니다.")
    print("다음 사항을 확인하세요:")
    print("  1. 다른 프로그램이 카메라를 사용 중인지 확인하고 종료하세요.")
    print("  2. 카메라 드라이버가 제대로 설치되었는지 확인하세요.")
    print("  3. 운영 체제 (예: Windows 개인 정보 설정)에서 Python 앱이 카메라에 접근할 수 있도록 허용했는지 확인하세요.")
    print("  4. 카메라 인덱스(0, 1, 2...)를 바꿔보세요.")
    sys.exit(1) # Exit if camera fails to open

# Set desired frame width and height
w = 640
h = 480
cap.set(cv2.CAP_PROP_FRAME_WIDTH, w)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, h)

# Get the actual frame dimensions and FPS from the camera
# This is important because the camera might not support the exact w, h you set.
# We'll use these actual values for VideoWriter.
actual_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
actual_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fps = cap.get(cv2.CAP_PROP_FPS)

# If FPS is 0 (can happen with some cameras or virtual cameras), set a default
if fps == 0:
    fps = 30.0 # Default to 30 FPS if camera doesn't report it

print(f"카메라 해상도 설정 시도: {w}x{h}")
print(f"실제 설정된 카메라 해상도: {actual_width}x{actual_height}")
print(f"실제 카메라 FPS: {fps}")

# --- VideoWriter 설정 ---
# 1. 출력 파일 이름
output_filename = 'output.mp4'

# 2. FourCC 코덱 (압축 방식)
# FourCC는 4바이트 코드로 비디오 코덱을 나타냅니다.
# MP4 파일의 경우 일반적으로 'mp4v' 또는 'XVID', 'DIVX'를 많이 사용합니다.
# 'mp4v' (MPEG-4)는 대부분의 시스템에서 잘 작동합니다.
# MacOS: 'avc1'
# Windows: 'XVID', 'DIVX', 'mp4v'
# H.264 코덱을 사용하려면 'X264' (때로는 작동하지 않을 수도 있음)
fourcc = cv2.VideoWriter_fourcc(*'mp4v') # *'mp4v'는 'm', 'p', '4', 'v'를 의미합니다.

# 3. FPS (프레임 레이트)
# 카메라의 실제 FPS를 사용하는 것이 가장 좋습니다.
output_fps = fps

# 4. 프레임 크기 (너비, 높이)
# 카메라에서 실제로 받아오는 프레임의 크기를 사용해야 합니다.
output_size = (actual_width, actual_height)

# VideoWriter 객체 생성
out = cv2.VideoWriter(output_filename, fourcc, output_fps, output_size)

# VideoWriter 객체가 성공적으로 생성되었는지 확인
if not out.isOpened():
    print(f"오류: 비디오 파일 '{output_filename}'을(를) 열 수 없습니다.")
    print("코덱(fourcc)이 올바른지, 파일 경로에 쓰기 권한이 있는지 확인하세요.")
    sys.exit(1)
# --- VideoWriter 설정 끝 ---

print("웹캠 스트리밍 및 output.mp4에 저장 시작...")
print("'q'를 눌러 종료하세요. 'Success' 메시지가 반복되는지 확인하세요.")

# 성공적으로 video device가 열렸으면 while문 반복
while(True): # cap.isOpened() 대신 True 사용 (위에서 이미 확인했으므로)
    # print("Success") # 이 메시지는 루프가 잘 돌아가는지 확인용, 너무 많으면 주석 처리
    ret, frame = cap.read()
    
    if not ret:
        print("프레임을 수신할 수 없습니다 (스트림 종료?). 종료합니다...")
        break # 루프 종료
    
    # 받은 프레임을 화면에 표시
    cv2.imshow("Camera", frame)
    
    # 받은 프레임을 output.mp4 파일에 쓰기
    out.write(frame)
    
    # 1ms동안 대기하며 키입력 받고 'q' 입력 시 종료
    key = cv2.waitKey(1)
    if key & 0xFF == ord('q'):
        print("사용자가 'q'를 눌러 종료합니다. 영상 저장을 완료합니다.")
        break

# 사용이 끝난 카메라 자원 해제
cap.release()
# VideoWriter 객체 해제 (이것이 파일을 최종적으로 완성하고 닫습니다)
out.release()
# 열려있는 모든 창 닫기
cv2.destroyAllWindows()

print(f"영상 저장 완료: {output_filename}")
```